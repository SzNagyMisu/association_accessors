# AssociationAccessors

**association_accessors** is a tool for generating accessors for `ActiveRecord` model associations based on columns other than the `id` (primary key).

## Table of Contents
<!--ts-->
   * [AssociationAccessors](#associationaccessors)
      * [Table of Contents](#table-of-contents)
      * [The Challenge](#the-challenge)
      * [Installation](#installation)
      * [Config](#config)
      * [Usage](#usage)
         * [With belongs_to](#with-belongs_to)
         * [With has_one](#with-has_one)
         * [With has_many](#with-has_many)
         * [With has_and_belongs_to_many](#with-has_and_belongs_to_many)
         * [With custom association names](#with-custom-association-names)
         * [With polymorphic associations](#with-polymorphic-associations)
      * [Test matcher](#test-matcher)
      * [TODO](#todo)
      * [Contributing](#contributing)
      * [License](#license)

<!-- Added by: misu, at: 2019-01-18T16:19+01:00 -->

<!--te-->

## The Challenge

You have the following tables:

```ruby
ActiveRecord::Schema.define do
  create_table :companies, force: true do |t|
    t.string :serial
    t.string :name
    # ...
  end

  create_table :users, force: true do |t|
    t.string :serial
    t.integer :company_id
    t.string :name
    # ...
  end
end
```

For security reasons it is decided that the frontend must not see the `id`s, only the `serial`s. So, when you want to change the company of a user, `params` will contain something like this:

```ruby
# <ActionController::Parameters { "serial": "9jco5RMp4K", "user": { company_serial: "MbyDB18lCi" } } permitted: false>
```

Now, if the `User` model has `#company_serial=` method, you can simply permit `:company_serial`.

Using **association_accessors** it amounts to this:

```ruby
class User < ActiveRecord::Base
  include AssociationAccessors

  belongs_to :company
  association_accessor_for :company, with_attribute: :serial
end
```

## Installation

Requirements:
* ruby >= 2.0

Add this line to your application's Gemfile:

```ruby
gem 'association_accessors', git: 'https://github.com/SzNagyMisu/association_accessors.git'
```

And then execute:

    $ bundle

## Config

It is possible to set a default value for the keyword `with_attribute:`, for example in an initializer:

```ruby
# config/initializers/association_accessors.rb
AssociationAccessors.default_attribute = :serial
```

## Usage

1. include the module `AssociationAccessors`.
2. define the associations
3. call `.association_accessor_for` method with the association name and the identifier attribute to generate the accessor methods:
    * for singular associations it will generate a reader and a writer along the rule `[association_name]_[attribute_name]`
    * for collection associations it will generate the methods along the rule `[singular_association_name]_[plural_attribute_name]`

These accessors work more or less the same way as the `id` accessors generated by default for the associations.

There are a few exceptions and some gotchas, though.

### With `belongs_to`

```ruby
# AssociationAccessors is included in the ApplicationRecord
class User < ApplicationRecord
  belongs_to :company, optional: true # only to demonstrate that it works with the association `nil`
  association_accessor_for :company, with_attribute: :serial
end
```

You have the methods `#company_id` and `#company_id=` because of the foreign key column. `association_accessors` generates the methods `#company_serial` and `#company_serial=`.

These work in a similar way with the following differences:
* `#company_id` is a column, `#company_serial` is a computed value (the `serial` of the `company`) - where `#company_id` can return value other than `nil` even without really having a `company`, `#company_serial` can only return the `serial` of the `company` (if any)
* `#company_id=` does not break if there is no company with the given id, only `#company` will return `nil` - whereas calling `#company_serial=` with a not existing serial will raise `ActiveRecord::RecordNotFound`

  ```ruby
  user.company          # => #<Company id: 10, serial: "HVuPpK">
  user.company_id       # => 10
  user.company_serial   # => "HVuPpK"

  user.company_id = 100 # there is no company with id=100
  user.company          # => nil
  user.company_id       # => 100
  user.company_serial   # => nil

  user.company_serial = 'EeNRM'
  # ActiveRecord::RecordNotFound (Couldn't find Company)
  ```

### With `has_one`

```ruby
class User < ApplicationRecord
  has_one :address
  association_accessor_for :address, with_attribute: :serial
end
```

There is no `#address_id` or `#address_id=` method for a `has_one` association. The generated methods (`#address_serial`, `#address_serial=`) behave the following way:
* `#address_serial` returns the `serial` of the `address` if any
* `#address_serial=`
  * changes the `user_id` column of the `adress`(es) setting it to `null` or to the `id` of the user as required
  * raises `ActiveRecord::RecordNotFound` if the given `serial` does not exist
  * raises `ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection` if association is defined with `through:` option

### With `has_many`

```ruby
class Company < ApplicationRecord
  has_many :users
  association_accessor_for :users, with_attribute: :serial
end
```

The generated methods (`#user_serials` and `#user_serials=`) will behave exactly the same way the [`collection_singular_ids`](https://guides.rubyonrails.org/association_basics.html#methods-added-by-has-many) accessor generated by `rails`:
* `#user_ids` will return the `id`s of the `users` - `#user_serials` will return the `serial`s of the `users`
* `#user_ids=` and `#user_serials=` will both
  * update the `company_id` column of the users: setting it to `null` or to the `id` of the company as required
  * raise `ActiveRecord::RecordNotFound` if any of the given `id`s or `serial`s is non-existing
  * raise `ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection` if association is defined with `:through` option

### With `has_and_belongs_to_many`

```ruby
class User < ApplicationRecord
  has_and_belongs_to_many :tasks
  association_accessor_for :tasks, with_attribute: :serial
end
```

The generated methods (`#task_serials` and `#task_serials=`) will behave exactly the same way the [`collection_singular_ids`](https://guides.rubyonrails.org/association_basics.html#methods-added-by-has-and-belongs-to-many) accessor generated by `rails`:
* `#task_ids` will return the `id`s of the `tasks` - `#task_serials` will return the `serial`s of the `tasks`
* `#task_ids=` and `#task_serials=` will both
  * update the join table adding or deleting records as required
  * raise `ActiveRecord::RecordNotFound` if any of the given `id`s or `serial`s is non-existing

### With custom association names

```ruby
class Node < ApplicationRecord
  belongs_to :parent, class_name: 'Node'
  association_accessor_for :parent, with_attribute: :serial

  has_many :children, class_name: 'Node', foreign_key: :parent_id
  association_accessor_for :children, with_attribute: :serial
end
```

The generated methods (`#parent_serial`, `#parent_serial=`, `#child_serials` and `#child_serials=`) work the same way, as they rely on the association, not the column.

### With polymorphic associations

```ruby
class User < ApplicationRecord
  has_one :image, as: :imageable
  association_accessor_for :image, with_attribute: :serial
end

class Task < ApplicationRecord
  has_many :images, as: :imageable
  association_accessor_for :images, with_attribute: :serial
end

class Image < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end
```

* The `has_one` and `has_many` parts work just fine, setting the `imageable_type` and `imageable_id` to `nil` or the class name and the `id` of the required record
* It is **not** recommended to use `association_accessors` for the `belongs_to` part of polymorphic associations, as the associated class is derived from the actual value of `[association_name]_type` column, causing unpredictable behavior and raising `NoMethodError` when it is `nil`

<!--
## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `rake spec` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).
-->

## Test matcher

**association_accessors** ships a test matcher too: `#have_association_accessor_for`. It surely works with [rspec](https://relishapp.com/rspec).

```ruby
RSpec.configure do |config|
  config.include AssociationAccessors::Test
end

RSpec.describe User, type: :model do
  it { should have_association_accessor_for(:company).with_attribute(:serial) }
end
```

So far, it checks if the reader and writer methods are defined on the subject, nothing more.

## TODO

* [ ] test against older rails versions

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/SzNagyMisu/association_accessors.

## License

The gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).
